
#include "push_swap.h"

char	**check_args(int argc, char **argv)
{
	char **args;
	int		i;

	args = NULL;
	i = 0;
	if (argc == 2)
	{
		args = ft_split(argv[1], ' ');
		if (!args)
			error_found();
	}
	else
		args = argv + 1;
	while (args[i])
	{
		if (syntax_check(args[i]) || !int_check(args[i]))
		{
			if (argc == 2)
				free_arrays(args);
			error_found();
		}
		i++;
	}
	return (args);
}

void	stack_append(t_stack **st_a, int nbr)
{
	t_stack	*new;
	t_stack	*last;

	new = malloc(sizeof(t_stack));
	if (!new)
	{
		free_stack(st_a);
		error_found();
	}
	new->nbr = nbr;
	new->next = NULL;
	if (*st_a == NULL)
		*st_a = new;
	else
	{
		last = stack_last(st_a);
		last->next = new;
	}
}

void	create_stack (int argc, char **argv, t_stack **st_a)
{
	char	**args;
	int		nbr;
	int		i;

	i = 0;
	args = check_args(argc, argv);
	while (args[i])
	{
		nbr = ft_atoi(args[i]);
		stack_append(st_a, nbr);
		i++;
	}
	if (argc == 2)
		free_arrays(args);
}

#include "push_swap.h"

bool	ascending_check(t_stack **st_a)
{
	t_stack	*tmp;

	tmp = *st_a;
	while (tmp->next)
	{
		if (tmp->nbr > tmp->next->nbr)
			return (false);
		tmp = tmp->next;
	}
	return (true);
}

bool	duplicates_check(t_stack *st_a)
{
	t_stack	*tmp;

	while (st_a)
	{
		tmp = st_a->next;
		while (tmp)
		{
			if (st_a->nbr == tmp->nbr)
				return (true);
			tmp = tmp->next;
		}
		st_a = st_a->next;
	}
	return (false);
}

bool	syntax_check(char *str)
{
	while ((*str == ' ') || (*str >= '\t' && *str <= '\r'))
		str++;
	if (*str == '-' || *str == '+')
		str++;
	if (!*str)
		return (true);
	while (*str)
	{
		if (!(*str >= '0' && *str <= '9'))
			return (true);
		str++;
	}
	return (false);
}

// Check 
bool	overflow_check(long nbr, int sign, char c)
{
	int	number;

	number = c - '0';
	if (nbr > INT_MAX / 10 || (nbr == INT_MAX / 10 && number > INT_MAX % 10))
		if (sign == 1)
			return (true);
	if (nbr > -(INT_MIN / 10)
			|| (nbr == -(INT_MIN / 10) && number > -(INT_MIN % 10)))
		if (sign == -1)
			return (true);
	return (false);
}

bool	int_check(char *str)
{
	int		sign;
	long	nbr;

	sign = 1;
	nbr = 0;
	while ((*str == ' ') || (*str >= '\t' && *str <= '\r'))
		str++;
	if (*str == '-' || *str == '+')
	{
		if (*str == '-')
			sign = -1;
		str++;
	}
	while (*str >= '0' && *str <= '9')
	{
		if (overflow_check(nbr, sign, *str) == true)
			return (false);
		nbr = nbr * 10 + *str - '0';
		str++;
	}
	nbr *= sign;
	return (true);
}

#include "push_swap.h"

void	ra_rb_rr(t_stack **a, t_stack **b, t_stack *node, t_stack *target)
{
	while (*a != node && *b != target)
		rotate_r(a, b);
	while (*a != node)
		rotate_a(a);
	while (*b != target)
		rotate_b(b);
}

void	rra_rrb_rrr(t_stack **a, t_stack **b, t_stack *node, t_stack *target)
{
	while (*a != node && *b != target)
		reverse_rotate_r(a, b);
	while (*a != node)
		reverse_rotate_a(a);
	while (*b != target)
		reverse_rotate_b(b);
}

void	ra_rra(t_stack **a, t_stack *node)
{
	if (node->info.rotate < node->info.reverse)
	{
		while (*a != node)
			rotate_a(a);
	}
	else
	{
		while (*a != node)
			reverse_rotate_a(a);
	}
}

void	rb_rrb(t_stack **b, t_stack *node)
{
	if (node->info.rotate < node->info.reverse)
	{
		while (*b != node)
			rotate_b(b);
	}
	else
	{
		while (*b != node)
			reverse_rotate_b(b);
	}
}

#include "push_swap.h"

int main(int ac, char **av)
{
	t_stack *st_a;
	t_stack *st_b;

	if (ac < 2)
		return (0);
	st_a = NULL;
	st_b = NULL;
	create_stack(ac, av, &st_a);
	if (!st_a || duplicates_check(st_a))
		free_exit(&st_a, &st_b);
	if(!ascending_check(&st_a))
		sort_stack(&st_a, &st_b);
	free_exit(&st_a, &st_b);
}

#include "push_swap.h"
// Functions to create
//  - push_a
void	move_push(t_stack **src, t_stack **dst)
{
	t_stack	*tmp;

	tmp = *src;
	*src = (*src)->next;
	tmp->next = *dst;
	*dst = tmp;
}

// - push_a
void	push_a(t_stack **src, t_stack **dst)
{
	if (!(*src))
		return ;
	move_push(src, dst);
	ft_printf("pa\n");
}

//  - push_b
void	push_b(t_stack **src, t_stack **dst)
{
	if (!(*src))
		return ;
	move_push(src, dst);
	ft_printf("pb\n");
}

#include "push_swap.h"
// Functions to create
void	reverse_rotate(t_stack **src)
{
	t_stack	*first;
	t_stack	*last;

	first = *src;
	last = NULL;
	while (first->next)
	{
		last = first;
		first = first->next;
	}
	last->next = NULL;
	first->next = *src;
	*src = first;
}
//  - reverse_a
void	reverse_rotate_a(t_stack **st)
{
	if (!(*st) || !(*st)->next)
		return ;
	reverse_rotate(st);
	ft_printf("rra\n");
}
//  - reverse_b
void	reverse_rotate_b(t_stack **st)
{
	if (!(*st) || !(*st)->next)
		return ;
	reverse_rotate(st);
	ft_printf("rrb\n");
}
//  - reverse_r
void	reverse_rotate_r(t_stack **st_a, t_stack **st_b)
{
	if (!(*st_a) || !(*st_b) || !(*st_a)->next || !(*st_b)->next)
		return ;
	reverse_rotate(st_a);
	reverse_rotate(st_b);
	ft_printf("rrr\n");
}

#include "push_swap.h"
// Functions to create
// - move_rotate
void	move_rotate(t_stack **src)
{
	t_stack	*first;
	t_stack	*last;

	first = *src;
	last = stack_last(src);
	*src = first->next;
	last->next = first;
	last->next = NULL;
}

// - rotate_a
void	rotate_a(t_stack **st)
{
	if (!(*st) || !(*st)->next)
		return ;
	move_rotate(st);
	ft_printf("ra\n");
}
// - rotate_b
void	rotate_b(t_stack **st)
{
	if (!(*st) || !(*st)->next)
		return ;
	move_rotate(st);
	ft_printf("rb\n");
}
// - rotate_r
void	rotate_r(t_stack **st_a, t_stack **st_b)
{
	if (!(*st_a) || !(*st_b) || !(*st_a)->next || !(*st_b)->next)
		return ;
	move_rotate(st_a);
	move_rotate(st_b);
	ft_printf("rr\n");
}

#include "push_swap.h"

void	move_swap(t_stack **src)
{
	t_stack	*tmp;

	tmp = *src;
	*src = (*src)->next;
	tmp->next = (*src)->next;
	(*src)->next = tmp;
}

// move_sa
void	swap_a(t_stack **st)
{
	if (!(*st) || (*st)->next == NULL)
		return ;
	move_swap(st);
	ft_printf("sa\n");
}

// move_sb
void	swap_b(t_stack **st)
{
	if (!(*st) || (*st)->next == NULL)
		return ;
	move_swap(st);
	ft_printf("sb\n");
}
// move_ss
void	swap_s(t_stack **st_a, t_stack **st_b)
{
	if (!(*st_a) || !(*st_b) || !(*st_a)->next || !(*st_b)->next)
		return ;
	move_swap(st_a);
	move_swap(st_b);
	ft_printf("ss\n");
}

#include "push_swap.h"

t_stack	*find_target_b(t_stack **dst, t_stack *node)
{
	t_stack	*target;
	t_stack	*tmp;

	tmp = *dst;
	target = NULL;
	if (node->nbr > tmp->nbr && node->nbr < stack_last(&tmp)->nbr)
		return (tmp);
	else if (node->nbr > stack_max(dst) || node->nbr < stack_min(dst))
	{
		while (tmp->nbr != stack_max(dst))
			tmp = tmp->next;
		target = tmp;
	}
	while (tmp->next)
	{
		if (node->nbr < tmp->nbr && node->nbr > tmp->next->nbr)
			target = tmp->next;
		tmp = tmp->next;
	}
	return (target);
}

int	execute_a(t_stack **src, t_stack **dst, t_stack *node, t_stack *target)
{
	int	moves;
	int	rev_moves;

	node->info.rotate = stack_position(src, node->nbr);
	target->info.rotate = stack_position(dst, target->nbr);
	node->info.reverse = stack_size(src) - stack_position(src, node->nbr);
	target->info.reverse = stack_size(dst) - stack_position(dst, target->nbr);
	moves = max_return(node->info.rotate, target->info.rotate);
	rev_moves = max_return(node->info.reverse, target->info.reverse);
	if (moves > node->info.rotate + target->info.reverse) // Check for optimizations
		moves = node->info.rotate + target->info.reverse;
	if (moves > node->info.reverse + target->info.rotate)
		moves = node->info.reverse + target->info.rotate;
	if (moves > rev_moves)
		moves = rev_moves;
	return (moves);
}

t_stack	*find_node_a(t_stack **src, t_stack **dst)
{
	t_stack *node;
	t_stack	*target;
	t_stack	*tmp;
	int		min;
	int		moves;

	tmp = *src;
	node = NULL;
	moves = INT_MAX;
	while (tmp)
	{
		target = find_target_b(dst, tmp);
		min = execute_a(src, dst, tmp, target);
		if (moves > min)
		{
			tmp->info.moves = min;
			moves = min;
			node = tmp;
		}
		tmp = tmp->next;
	}
	return (node);
}

void	a_to_b(t_stack **src, t_stack **dst)
{
	t_stack	*node;
	t_stack	*target;

	while(stack_size(src) > 3 && !ascending_check(src))
	{
		node = find_node_a(src, dst);
		target = find_target_b(dst, node);
		if (node->info.moves == node->info.rotate
				|| node->info.moves == target->info.rotate)
			ra_rb_rr(src, dst, node, target);
		else if (node->info.moves == node->info.reverse 
				|| node->info.moves == target->info.reverse)
			rra_rrb_rrr(src, dst, node, target);
		else
		{
			ra_rra(src, node);
			rb_rrb(dst, target);
		}
		push_b(src, dst);
	}
}

#include "push_swap.h"

t_stack	*find_target_a(t_stack **src, t_stack *node)
{
	t_stack	*target;
	t_stack	*tmp;

	tmp = *src;
	target = NULL;
	if (node->nbr < tmp->nbr && node->nbr > stack_last(&tmp)->nbr)
		return (tmp);
	if (node->nbr > stack_max(src) || node->nbr < stack_min(src))
	{
		while (tmp->nbr != stack_min(src))
			tmp = tmp->next;
		target = tmp;
	}
	while (tmp->next)
	{
		if (node->nbr > tmp->nbr && node->nbr < tmp->next->nbr)
			target = tmp->next;
		tmp = tmp->next;
	}
	return (target);
}

int	execute_b(t_stack **dst, t_stack **src, t_stack *node, t_stack *target)
{
	int	moves;
	int	rev_moves;

	node->info.rotate = stack_position(src, node->nbr);
	target->info.rotate = stack_position(dst, target->nbr);
	node->info.reverse = stack_size(src) - stack_position(src, node->nbr);
	target->info.reverse = stack_size(dst) - stack_position(dst, target->nbr);
	moves = max_return(node->info.rotate, target->info.rotate);
	rev_moves = max_return(node->info.reverse, target->info.reverse);
	if (moves > node->info.rotate + target->info.reverse)
		moves = node->info.rotate + target->info.reverse;
	if (moves > node->info.reverse + target->info.rotate)
		moves = node->info.reverse + target->info.rotate;
	if (moves > rev_moves)
		moves = rev_moves;
	return (moves);
}

t_stack	*find_node_b(t_stack **dst, t_stack **src)
{
	t_stack *node;
	t_stack	*target;
	t_stack	*tmp;
	int		min;
	int		moves;

	tmp = *src;
	node = NULL;
	moves = INT_MAX;
	while (tmp)
	{
		target = find_target_a(dst, tmp);
		min = execute_b(dst, src, tmp, target);
		if (moves > min)
		{
			tmp->info.moves = min;
			moves = min;
			node = tmp;
		}
		tmp = tmp->next;
	}
	return (node);
}

void	b_to_a(t_stack **dst, t_stack **src)
{
	t_stack	*node;
	t_stack	*target;

	while(*src)
	{
		node = find_node_b(dst, src);
		target = find_target_a(dst, node);
		if (node->info.moves == node->info.rotate
				|| node->info.moves == target->info.rotate)
			ra_rb_rr(dst, src, target, node);
		else if (node->info.moves == node->info.reverse 
				|| node->info.moves == target->info.reverse)
			rra_rrb_rrr(dst, src, target, node);
		else
		{
			ra_rra(dst, target);
			rb_rrb(src, node);
		}
		push_a(src, dst);
	}
}

#include "push_swap.h"

void	sort_big(t_stack **st_a, t_stack **st_b)
{
	int	i;

	i = 2;
	while (stack_size(st_a) > 3 && i--)
		push_b(st_a, st_b);
	if (stack_size(st_a) > 3)
		a_to_b(st_a, st_b);
	ft_printf("Stack a\n");
	print_stack(*st_a);
	ft_printf("Stack b\n");
	print_stack(*st_b);
	if (!ascending_check(st_a))
		sort_three(st_a);
	b_to_a(st_a, st_b);
	if (!ascending_check(st_a))
	{
		i = stack_position(st_a, stack_min(st_a));
		if (i <= stack_size(st_a) / 2)
		{
			while ((*st_a)->nbr != stack_min(st_a))
				rotate_a(st_a);
		}
		else
		{
			while ((*st_a)->nbr != stack_min(st_a))
				reverse_rotate_a(st_a);
		}
	}
}

void	sort_three(t_stack **st_a)
{
	if ((*st_a)->nbr == stack_max(st_a))
		rotate_a(st_a);
	else if ((*st_a)->next->nbr == stack_max(st_a))
		reverse_rotate_a(st_a);
	if ((*st_a)->nbr > (*st_a)->next->nbr)
		swap_a(st_a);
}

void	sort_stack(t_stack **st_a, t_stack **st_b)
{
	if (stack_size(st_a) == 2)
		swap_a(st_a);
	else if (stack_size(st_a) == 3)
		sort_three(st_a);
	else
		sort_big(st_a, st_b);
}

#include "push_swap.h"

t_stack	*stack_last(t_stack **st)
{
	t_stack	*tmp;

	tmp = *st;
	while(tmp->next)
		tmp = tmp->next;
	return(tmp);
}

int	stack_size(t_stack **st)
{
	int		i;
	t_stack	*tmp;

	i = 0;
	tmp = *st;
	while (tmp)
	{
		i++;
		tmp = tmp->next;
	}
	return (i);
}

int	stack_max(t_stack **st)
{
	int	max;
	t_stack	*tmp;

	tmp = *st;
	max = tmp->nbr;
	while (tmp)
	{
		if (tmp->nbr > max)
			max = tmp->nbr;
		tmp = tmp->next;
	}
	return (max);
}

int	stack_min(t_stack **st)
{
	int	min;
	t_stack	*tmp;

	tmp = *st;
	min = tmp->nbr;
	while (tmp)
	{
		if (tmp->nbr < min)
			min = tmp->nbr;
		tmp = tmp->next;
	}
	return (min);
}

int	stack_position(t_stack **st, int nbr)
{
	int		i;
	t_stack	*tmp;

	i = 0;
	tmp = *st;
	while(tmp && tmp->nbr != nbr)
	{
		tmp = tmp->next;
		i++;
	}
	return (i);
}

#include "push_swap.h"

void	free_stack(t_stack **st)
{
	t_stack	*tmp;

	if(!st || !*st)
		return ;
	while (*st)
	{
		tmp = (*st)->next;
		free(*st);
		*st = tmp;
	}
}

void	free_arrays(char **av)
{
	int	i;

	i = 0;
	if (av)
	{
		while(av[i])
		{
			free(av[i]);
			av[i] = NULL;
			i++;
		}
		free(av);
	}
}

void	error_found(void)
{
	ft_putstr_fd("Error\n", 2);
	exit(1);
}

void	free_exit(t_stack **st_a, t_stack **st_b)
{
	free_stack(st_a);
	free_stack(st_b);
	exit(0);
}

int	max_return(int a, int b)
{
	if (a > b)
		return (a);
	else
		return (b);
}

void	print_stack(t_stack *st)
{
	t_stack	*tmp;

	tmp = st;
	while(tmp != NULL)
	{
		ft_printf("%d\n", tmp->nbr);
		tmp = tmp->next;
	}
}
#ifndef PUSH_SWAP_H
# define PUSH_SWAP_H

// Libraries
# include "library/libft/libft.h"
# include <stdbool.h>
# include <limits.h>

typedef struct s_info
{
	int moves;
	int rotate;
	int reverse;
} t_info;

typedef struct s_stack
{
	int		nbr;
	t_info	info;
	struct s_stack *next;
} t_stack;

// check_data.c
char	**check_args(int ac, char **av);
void	stack_append(t_stack **st_a, int nbr);
void	create_stack (int ac, char **av, t_stack **st_a);

// check_errors.c
bool	int_check(char *str);
bool	syntax_check(char *str);
bool	ascending_check(t_stack **st_a);
bool	duplicates_check(t_stack *st_a);
bool	overflow_check(long nbr, int sign, char c);

// push_swap.c
void	long_check(char *str);
void	push_swap(char **av, t_stack **st);

// executions_choice.c
void	ra_rra(t_stack **st_a, t_stack *node);
void	rb_rrb(t_stack **st_b, t_stack *node);
void	ra_rb_rr(t_stack **st_a, t_stack **st_b, t_stack *node, t_stack *target);
void	rra_rrb_rrr(t_stack **st_a, t_stack **st_b, t_stack *node, t_stack *target);

//operations_a
void	a_to_b(t_stack **src, t_stack **dst);
t_stack	*find_target_b(t_stack **dst, t_stack *node);
t_stack	*find_node_b(t_stack **src, t_stack **dst);
int	execute_a(t_stack **src, t_stack **dst, t_stack *node, t_stack *target);

// operations_b.c
void	b_to_a(t_stack **src, t_stack **dst);
t_stack	*find_target_a(t_stack **dst, t_stack *node);
t_stack	*find_node_a(t_stack **src, t_stack **dst);
int		execute_b(t_stack **src, t_stack **dst, t_stack *node, t_stack *target);

// stack operations
int	stack_size(t_stack **st);
int	stack_max(t_stack **stack);
int	stack_min(t_stack **stack);
int	stack_position(t_stack **stack, int nbr);
t_stack	*stack_last(t_stack **st);

// sort.c
void	sort_three(t_stack **st_a);
void	sort_big(t_stack **st_a, t_stack **st_b);
void	sort_stack(t_stack **st_a, t_stack **st_b);

// moves 
void	move_push(t_stack **src, t_stack **dst);
void	push_a(t_stack **src, t_stack **dst);
void	push_b(t_stack **src, t_stack **dst);

void	move_swap(t_stack **src);
void	swap_a(t_stack **st);
void	swap_b(t_stack **st);
void	swap_s(t_stack **st_a, t_stack **st_b);

void	move_rotate(t_stack **src);
void	rotate_a(t_stack **st);
void	rotate_b(t_stack **st);
void	rotate_r(t_stack **st_a, t_stack **st_b);

void	move_reverse_rotate(t_stack **src);
void	reverse_rotate_a(t_stack **st);
void	reverse_rotate_b(t_stack **st);
void	reverse_rotate_r(t_stack **st_a, t_stack **st_b);

// utils
int		max_return(int a, int b);
void	free_stack(t_stack **st);
void	free_arrays(char **av);
void	error_found(void);
void	free_exit(t_stack **st_a, t_stack **st_b);


// delete
void	print_stack(t_stack *st);

#endif // !PUSH_SWAP_H
